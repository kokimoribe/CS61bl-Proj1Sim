We implemented our board as a HashMap (an unindexed list of key-value pairs) with each connector object being the key, and its corresponding color as the value. The board is initialized with all 15 possible connectors, with each given the default color white. This representation allowed us an added level of abstraction when writing methods to access the board. Instead of keeping each connector object organized in an array where its index corresponds to its points in some way, we can access connector objects we need in a HashMap without needing to know anything about it (i.e. what index it's at or what endpoints it represents). This also makes coding easier and more dependable since working with indexes often produces errors or accesses elements one off from the intended one. Moreover, as we all wished that color were another instance variable of the Connector class, HashMaps provided the most straightforward and intuitive way of relating each connector to its color.

Our logic for the choice method is as follows:
First, find all possible moves i.e. all moves that won't end up forming a blue triangle.
Second, out of all the possible moves, avoid choosing a move that is a losing move for the opponent i.e. don't choose a connector that would form a red triangle.
Third, out of all the moves that avoids a losing move for the opponent, choose a move that will prevent two blue connectors from sharing the same point.
The first step will prevent choosing a losing move when there could be other available moves.
The second step increases the chance that the opponent will choose a losing move, or increases the chance that the opponent is left with losing moves.
The third step decreases the number of possible losing moves for the future.

As a team we attempted to follow a test-driven development plan that made sure each method worked before we moved on to another method that built on it. Since some of the methods and the constructor were fairly straightforward given our implementation of the board using HashMaps (i.e. colorOf, add, connectors), we were confident in coding these first with minimal testing. This instinct turned out to save us time and allowed us to work on the more complicated methods sooner so we could spend more time debugging.

Daniel (cs61bl-hq): My main contribution was in planning the implementation of the board as a HashMap and determining how the toConnector method would communicate with the add method on a board already full of white connectors by simply changing the color. We also both were able to help each other get through design challenges and take the time to help each other with code. I'm also really happy that we as a team were both able to work on the project at a similar pace, so not only was no one left behind in terms of knowledge about the project, but also we had ample time to test and perfect our methods, tests, and comments without being rushed at the last minute.
Koki (cs61bl-fl): My main contribution was devising an approach for the formsTriangle method as well as extending the choice method. Overall, we helped each other in various ways as we were working together at a similar pace. This allowed us to discuss our approaches to the solutions of the code and help each other out with debugging if either of us had any problems. 
